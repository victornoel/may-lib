
import java.lang.String
import fr.irit.smac.may.lib.interfaces.*
import fr.irit.smac.may.lib.classic.interfaces.*
import fr.irit.smac.may.lib.components.meta.*
import fr.irit.smac.may.lib.components.scheduling.*
import fr.irit.smac.may.lib.components.messaging.*
import fr.irit.smac.may.lib.components.messaging.receiver.*
import fr.irit.smac.may.lib.components.controlflow.*
import fr.irit.smac.may.lib.components.remote.place.*
import fr.irit.smac.may.lib.components.remote.messaging.receiver.*
import fr.irit.smac.may.lib.components.remote.messaging.receiver.RemoteAgentRef
import fr.irit.smac.may.lib.components.remote.place.Place
import fr.irit.smac.may.lib.components.messaging.receiver.AgentRef

import java.util.concurrent.Executor

import fr.irit.smac.may.lib.classic.*

namespace fr.irit.smac.may.lib.classic {

	namespace named {
		
		ecosystem ClassicNamed[Msg] {
			provides send: Send[Msg, String] = receive.depositKey
			provides create: CreateNamed[Msg, String]
			
			component scheduler: Scheduler {
				bind infraSched to executor.exec
			}

			component sender: Forward[Send[Msg, String]] {
				bind i to receive.depositKey
			}
			
			component fact: Forward[CreateNamed[Msg, String]] {
				bind i toThis create
			}
			
			component realReceive: Receiver[Msg]
			
			component receive: MapReceiver[Msg,AgentRef,String] {
				bind depositValue to realReceive.deposit
			}
			
			component executor: ExecutorService
			
			species ClassicNamedAgent(beh: named.ClassicNamedBehaviour[Msg,String], name: String) {
				
				component arch: ClassicNamedAgentComponent[Msg, String] {
					bind send to ss.a
					bind executor to s.sched
					bind die to s.stop
					bind create to f.a
				}

				with s: scheduler.Agent

				with f: fact.Agent

				with r: receive.Agent {
					bind key to arch.me
					bind value to rr.me
				}
				
				with rr: realReceive.Agent(name) {
					bind put to arch.put
				}

				with ss: sender.Agent
			}
		}
		
		component ClassicNamedBehaviour[Msg, Ref] {
			provides cycle: Push[Msg]
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires die: Do
			requires create: CreateNamed[Msg, Ref]
		}
		
		component ClassicNamedAgentComponent[Msg, Ref] {
			
			provides put: Push[Msg] = dispatcher.dispatch
			provides me: Pull[Ref] = name.data
			
			requires send: Send[Msg, Ref]
			requires executor: Executor
			requires die: Do
			requires create: CreateNamed[Msg, Ref]

			component name: Data[Ref]

			component dispatcher: SequentialDispatcher[Msg] {
				bind executor toThis executor
				bind handler to beh.cycle
			}
			
			component beh: ClassicNamedBehaviour[Msg, Ref] {
				bind send toThis send
				bind me toThis me
				bind die toThis die
				bind create toThis create
			}

		}
	}

	namespace local {
		
		component ClassicBehaviour[Msg, Ref] {
			provides cycle: Push[Msg]
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires die: Do
			requires create: CreateClassic[Msg, Ref]
		}
		
		ecosystem Classic[Msg] {

			provides send: Send[Msg, AgentRef] = receive.deposit
			provides create: CreateClassic[Msg, AgentRef]
			provides stop: Do = executor.stop

			component scheduler: Scheduler {
				bind infraSched to executor.exec
			}

			component sender: Forward[Send[Msg, AgentRef]] {
				bind i to receive.deposit
			}

			component receive: Receiver[Msg]

			component fact: fr.irit.smac.may.lib.components.meta.Forward[CreateClassic[Msg, AgentRef]] {
				bind i toThis create
			}

			component executor: ExecutorService

			species ClassicAgent(beh: local.ClassicBehaviour[Msg,AgentRef], name: String) {
				
				provides ref: Pull[AgentRef] = r.me
				
				component arch: ClassicAgentComponent[Msg, AgentRef] {
					bind send to ss.a
					bind me to r.me
					bind executor to s.sched
					bind die to s.stop
					bind create to f.a
				}

				with s: scheduler.Agent

				with f: fact.Agent

				with r: receive.Agent(name) { 
					bind put to arch.put
				}

				with ss: sender.Agent
			}
		}

		component ClassicAgentComponent[Msg, Ref] {
			provides put: Push[Msg] = dispatcher.dispatch
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires executor: Executor
			requires die: Do
			requires create: CreateClassic[Msg, Ref]

			component dispatcher: SequentialDispatcher[Msg] {
				bind executor toThis executor
				bind handler to beh.cycle
			}
			component beh: ClassicBehaviour[Msg, Ref] {
				bind send toThis send
				bind me toThis me
				bind die toThis die
				bind create toThis create
			}
		}
	}

	namespace remote {

		component RemoteClassicBehaviour[Msg, Ref] {
			provides cycle: Push[Msg]
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires die: Do
			requires create: CreateRemoteClassic[Msg, Ref]
		}

		component RemoteClassicAgentComponent[Msg, Ref] {
			provides put: Push[Msg] = dispatcher.dispatch
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires executor: Executor
			provides die: Do
			requires stopExec: Do
			requires stopReceive: Do
			requires create: CreateRemoteClassic[Msg, Ref]

			component dispatcher: SequentialDispatcher[Msg] {
				bind executor toThis executor
				bind handler to beh.cycle
			}
			component beh: RemoteClassicBehaviour[Msg, Ref] {
				bind send toThis send
				bind me toThis me
				bind die toThis die
				bind create toThis create
			}
		}

		ecosystem RemoteFactory[Msg, Ref] {
			species Agent {
				provides create: CreateRemoteClassic[Msg, Ref]
			}
			requires infraCreate: CreateRemoteClassic[Msg, Ref]
			provides factCreate: CreateRemoteClassic[Msg, Ref]
			requires thisPlace: Pull[Place]
		}
		


		ecosystem RemoteClassic[Msg] {

			provides send: Send[Msg, RemoteAgentRef] = remReceive.deposit
			provides thisPlace: Pull[Place] = placed.thisPlace
			provides create: CreateRemoteClassic[Msg, RemoteAgentRef]

			component scheduler: Scheduler {
				bind infraSched to executor.exec
			}

			component sender: Forward[Send[Msg, RemoteAgentRef]] {
				bind i to remReceive.deposit
			}

			component receive: Receiver[Msg]

			component placed: Placed

			component remReceive: RemoteReceiver[Msg, AgentRef] {
				bind localDeposit to receive.deposit
				bind myPlace to placed.thisPlace
			}

			component fact: RemoteFactory[Msg, RemoteAgentRef] {
				bind infraCreate toThis create
				bind thisPlace to placed.thisPlace
			}

			component executor: ExecutorService

			species ClassicAgent(beh: remote.RemoteClassicBehaviour[Msg, RemoteAgentRef], name: String) {
				
				provides ref: Pull[RemoteAgentRef] = rr.me
				component arch: RemoteClassicAgentComponent[Msg, RemoteAgentRef] {
					bind send to ss.a
					bind me to rr.me
					bind stopExec to s.stop
					bind stopReceive to rr.disconnect
					bind executor to s.sched
					bind create to f.create
				}
				with p: placed.Agent
				with f: fact.Agent
				with s: scheduler.Agent
				with r: receive.Agent(name) {
					bind put to arch.put
				}
				with ss: sender.Agent
				with rr: remReceive.Agent {
					bind localMe to r.me
				}
			}
		}
	}
}