
import java.lang.String
import fr.irit.smac.may.lib.interfaces.*
import fr.irit.smac.may.lib.classic.interfaces.*
import fr.irit.smac.may.lib.components.meta.*
import fr.irit.smac.may.lib.components.scheduling.*
import fr.irit.smac.may.lib.components.messaging.*
import fr.irit.smac.may.lib.components.messaging.receiver.*
import fr.irit.smac.may.lib.components.controlflow.*
import fr.irit.smac.may.lib.components.remote.place.*
import fr.irit.smac.may.lib.components.remote.messaging.receiver.*
import fr.irit.smac.may.lib.components.remote.messaging.receiver.RemoteAgentRef
import fr.irit.smac.may.lib.components.remote.place.Place
import fr.irit.smac.may.lib.components.messaging.receiver.AgentRef

import java.util.concurrent.Executor

import fr.irit.smac.may.lib.classic.*

import java.lang.*

namespace fr.irit.smac.may.lib.classic {

	namespace namedPublish {
		
		import fr.irit.smac.may.lib.components.interactions.*
		import fr.irit.smac.may.lib.components.interactions.interfaces.Observe
		
		component ObservedBehaviour {
			provides cycle: Do
			requires changeValue: Push[Integer]
		}
		
		component ObserverBehaviour[Ref] {
			provides cycle: Do
			requires observe: Observe[Integer,Ref]
		}
		
		ecosystem NamedPublishMAS {
			
			provides create: namedpub.NamedPublishMASFactory
			
			part refs: MapReferences[Pull[Integer],String]
			part observeds: ValuePublisher[Integer,String] {
				bind call to refs.call
			}
			part observers: Forward[Observe[Integer,String]] {
				bind i to observeds.observe
			}
			
			part executor: ExecutorService
			part schedule: Scheduled {
				bind sched to executor.exec
			}
			part clock: Clock {
				bind sched to executor.exec
				bind tick to schedule.tick
			}
			part gui: SchedulingControllerGUI {
				bind control to clock.control
			}

			species Observed(name: String, beha: namedpub.AbstractObservedBehaviour) {

				use sched: schedule.Agent {
					bind cycle to beh.cycle
				}
				
				part beh: ObservedBehaviour {
					bind changeValue to observed.set
				}
			
				use ref: refs.Callee(name) {
					bind toCall to observed.get
				}
				use observed: observeds.PublisherPush
				
			}
			
			species Observer(beha: namedpub.AbstractObserverBehaviour[String]) {
				
				use sched: schedule.Agent {
					bind cycle to beh.cycle
				}
				
				part beh: ObserverBehaviour[String] {
					bind observe to observer.a
				}
				use observer: observers.Agent
				
			}
			
		}
	}

	namespace named {
		
		ecosystem ClassicNamed[Msg] {
			provides send: Send[Msg, String] = receive.deposit
			provides create: CreateNamed[Msg, String]
			
			part scheduler: Scheduler {
				bind infraSched to executor.exec
			}

			part sender: Forward[Send[Msg, String]] {
				bind i to receive.deposit
			}
			
			part fact: Forward[CreateNamed[Msg, String]] {
				bind i toThis create
			}
			
			part refs: fr.irit.smac.may.lib.components.interactions.MapReferences[Push[Msg],String]
			part receive: fr.irit.smac.may.lib.components.interactions.AsyncReceiver[Msg,String] {
				bind call to refs.call
			}
			
			part executor: ExecutorService
			
			species ClassicNamedAgent(beh: named.ClassicNamedBehaviour[Msg,String], name: String) {
			//species ClassicNamedAgent(name: String) {
				part arch: ClassicNamedAgentComponent[Msg, String] {
					bind send to ss.a
					bind executor to s.sched
					bind die to s.stop
					bind create to f.a
					bind me to ref.me
				}

				use s: scheduler.Agent

				use f: fact.Agent

				// no need for receiver because we don't want the buffer
				// that's a bit ugly btw
				use ref: refs.Callee(name) {
					bind toCall to arch.put
				}

				use ss: sender.Agent
			}
		}
		
		component ClassicNamedBehaviour[Msg, Ref] {
			provides cycle: Push[Msg]
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires die: Do
			requires create: CreateNamed[Msg, Ref]
		}
		
		component ClassicNamedAgentComponent[Msg, Ref] {
			
			provides put: Push[Msg] = dispatcher.dispatch
			
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires executor: Executor
			requires die: Do
			requires create: CreateNamed[Msg, Ref]

			part dispatcher: SequentialDispatcher[Msg] {
				bind executor toThis executor
				bind handler to beh.cycle
			}
			
			part beh: ClassicNamedBehaviour[Msg, Ref] {
				bind send toThis send
				bind me toThis me
				bind die toThis die
				bind create toThis create
			}

		}
	}

	namespace local {
		import fr.irit.smac.may.lib.components.interactions.directreferences.DirRef
		
		component ClassicBehaviour[Msg, Ref] {
			provides cycle: Push[Msg]
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires die: Do
			requires create: CreateClassic[Msg, Ref]
		}
		
		ecosystem Classic[Msg] {

			provides send: Send[Msg, DirRef] = receive.deposit
			provides create: CreateClassic[Msg, DirRef]
			provides stop: Do = executor.stop

			part scheduler: Scheduler {
				bind infraSched to executor.exec
			}

			part sender: Forward[Send[Msg, DirRef]] {
				bind i to receive.deposit
			}
			
			part refs: fr.irit.smac.may.lib.components.interactions.DirectReferences[Push[Msg]]
			part receive: fr.irit.smac.may.lib.components.interactions.AsyncReceiver[Msg,DirRef] {
				bind call to refs.call
			}

			part fact: Forward[CreateClassic[Msg, DirRef]] {
				bind i toThis create
			}

			part executor: ExecutorService

			species ClassicAgent(beh: local.ClassicBehaviour[Msg,DirRef], name: String) {
			//species ClassicAgent(name: String) {
				provides me: Pull[DirRef] = ref.me
				
				part arch: ClassicAgentComponent[Msg, DirRef] {
					bind send to ss.a
					bind me to ref.me
					bind executor to s.sched
					bind die to s.stop
					bind create to f.a
				}

				use s: scheduler.Agent

				use f: fact.Agent
				
				// no need for receiver because we don't want the buffer
				// that's a bit ugly btw
				use ref: refs.Callee(name) {
					bind toCall to arch.put
				}

				use ss: sender.Agent
			}
		}

		component ClassicAgentComponent[Msg, Ref] {
			provides put: Push[Msg] = dispatcher.dispatch
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires executor: Executor
			requires die: Do
			requires create: CreateClassic[Msg, Ref]

			part dispatcher: SequentialDispatcher[Msg] {
				bind executor toThis executor
				bind handler to beh.cycle
			}
			part beh: ClassicBehaviour[Msg, Ref] {
				bind send toThis send
				bind me toThis me
				bind die toThis die
				bind create toThis create
			}
		}
	}

	namespace remote {

		component RemoteClassicBehaviour[Msg, Ref] {
			provides cycle: Push[Msg]
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires die: Do
			requires create: CreateRemoteClassic[Msg, Ref]
		}

		component RemoteClassicAgentComponent[Msg, Ref] {
			provides put: Push[Msg] = dispatcher.dispatch
			requires send: Send[Msg, Ref]
			requires me: Pull[Ref]
			requires executor: Executor
			provides die: Do
			requires stopExec: Do
			requires stopReceive: Do
			requires create: CreateRemoteClassic[Msg, Ref]

			part dispatcher: SequentialDispatcher[Msg] {
				bind executor toThis executor
				bind handler to beh.cycle
			}
			part beh: RemoteClassicBehaviour[Msg, Ref] {
				bind send toThis send
				bind me toThis me
				bind die toThis die
				bind create toThis create
			}
		}

		ecosystem RemoteFactory[Msg, Ref] {
			species Agent {
				provides create: CreateRemoteClassic[Msg, Ref]
			}
			requires infraCreate: CreateRemoteClassic[Msg, Ref]
			provides factCreate: CreateRemoteClassic[Msg, Ref]
			requires thisPlace: Pull[Place]
		}
		


		ecosystem RemoteClassic[Msg] {

			provides send: Send[Msg, RemoteAgentRef] = remReceive.deposit
			provides thisPlace: Pull[Place] = placed.thisPlace
			provides create: CreateRemoteClassic[Msg, RemoteAgentRef]

			part scheduler: Scheduler {
				bind infraSched to executor.exec
			}

			part sender: Forward[Send[Msg, RemoteAgentRef]] {
				bind i to remReceive.deposit
			}

			part receive: Receiver[Msg]

			part placed: Placed

			part remReceive: RemoteReceiver[Msg, AgentRef] {
				bind localDeposit to receive.deposit
				bind myPlace to placed.thisPlace
			}

			part fact: RemoteFactory[Msg, RemoteAgentRef] {
				bind infraCreate toThis create
				bind thisPlace to placed.thisPlace
			}

			part executor: ExecutorService

			species ClassicAgent(beh: remote.RemoteClassicBehaviour[Msg, RemoteAgentRef], name: String) {
			//species ClassicAgent(name: String) {
				provides ref: Pull[RemoteAgentRef] = rr.me
				part arch: RemoteClassicAgentComponent[Msg, RemoteAgentRef] {
					bind send to ss.a
					bind me to rr.me
					bind stopExec to s.stop
					bind stopReceive to rr.disconnect
					bind executor to s.sched
					bind create to f.create
				}
				use p: placed.Agent
				use f: fact.Agent
				use s: scheduler.Agent
				use r: receive.Agent(name) {
					bind put to arch.put
				}
				use ss: sender.Agent
				use rr: remReceive.Agent {
					bind localMe to r.me
				}
			}
		}
	}
}